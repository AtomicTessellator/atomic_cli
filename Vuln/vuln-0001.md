# Insecure Storage of Authentication Tokens in Plaintext

**ID:** vuln-0001
**Severity:** HIGH
**Found:** 2025-10-16 16:15:32 UTC

## Description

### Vulnerability Description
The Atomic Tessellator CLI application stores authentication tokens in plaintext within a JSON configuration file located at ~/.config/atomict/config.json (or equivalent OS-specific paths like ~/Library/Application Support/atomict on macOS or %APPDATA%/atomict on Windows). This occurs during the authentication process when a token is obtained from the server via username/password and persisted using the store() function in env.py. The token is then retrieved and used in subsequent API calls via the APIClient in cli/core/client.py.

This insecure storage mechanism exposes the authentication token to unauthorized access by any user or process with read permissions on the user's home directory. Since the token grants access to the user's account on the Atomic Tessellator API (https://api.atomictessellator.com), an attacker with local access (e.g., via malware, shared environment, or compromised user session) can steal the token and impersonate the user, leading to full account takeover.

The application uses a simple Token-based authentication scheme (not JWT), where the token is set as an Authorization header ("Token {token}"). There are no measures for token encryption, obfuscation, or secure storage integration (e.g., OS credential managers). Additionally, the fallback authentication logic in auth.py and resolve_token() prioritizes environment variables (AT_TOKEN, AT_USER, AT_PASS) but defaults to persistent storage, exacerbating the risk in multi-user or persistent environments.

No validation of token expiration or revocation is performed client-side, allowing stolen tokens to remain valid until server-side expiry.

### Affected Components
- auth.py: Handles authentication via post() to "api-auth/" and stores the token using env.store("token", response["token"]).
- env.py: Implements store(), get(), and get_config_path() functions, which write/read the token in plaintext JSON to the user config directory.
- cli/core/client.py: APIClient class retrieves the token via resolve_token() or config, sets it in headers, and uses it for all API interactions. The get_client() function ensures authentication and persists the token.

### Proof of Concept
To demonstrate the vulnerability, simulate the authentication flow in a controlled environment:

1. **Setup**: Ensure the application is installed (pip install -e . in /workspace). The codebase is at /workspace/atomict.

2. **Simulate Token Storage**:
   - Use Python to import and call the store mechanism:
     ```
     import sys
     sys.path.insert(0, '/workspace')
     from atomict.env import store
     mock_token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"  # Mock token
     store("token", mock_token)
     ```
   - This mimics the real flow in auth.py where authenticate() calls store("token", response["token"]).

3. **Verify Plaintext Storage**:
   - The token is written to /home/pentester/.config/atomict/config.json (Linux path; adjust for OS).
   - File contents (cat /home/pentester/.config/atomict/config.json):
     ```
     {"token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"}
     ```
   - Evidence: The token is stored unencrypted and directly readable. In a real scenario, running `tess login` with credentials would produce the same result after server response.

4. **Exploit Simulation**:
   - An attacker reads the file: `cat ~/.config/atomict/config.json | jq -r .token` to extract the token.
   - Use the token in a malicious script:
     ```
     import requests
     headers = {"Authorization": f"Token {stolen_token}"}
     response = requests.get("https://api.atomictessellator.com/api/user/", headers=headers)
     print(response.json())  # Accesses user data as the victim
     ```
   - This bypasses login, demonstrating account takeover.

The config directory is created with default permissions (755 for dir, 644 for file), readable by the user and potentially others in shared environments.

### Impact
- **Confidentiality**: Exposure of sensitive user data (projects, simulations, API keys) via stolen token.
- **Authentication Bypass**: Attacker gains persistent access to the victim's account without credentials.
- **Account Takeover**: Full control over the victim's Atomic Tessellator account, including running simulations, managing projects, and potentially incurring costs or leaking proprietary computational chemistry data.
- **Scope**: Affects all users of the CLI on multi-user systems, shared workstations, or if the config is synced/backed up insecurely (e.g., via cloud storage).
- **CVSS v3.1 Score**: 7.8 (High) - Attack Vector: Local; Attack Complexity: Low; Privileges Required: Low; User Interaction: None; Scope: Unchanged; Confidentiality: High; Integrity: High; Availability: Low.

Business impact: In a research/enterprise setting, this could lead to intellectual property theft (e.g., proprietary molecular models) or unauthorized compute resource usage.

### Remediation Recommendations
1. **Secure Storage**: Integrate the keyring library (pip install keyring) to store tokens in the OS credential manager (e.g., macOS Keychain, Windows Credential Manager, Linux Secret Service). Modify env.py's store() and get() to use keyring.set_password("atomict", "token", value) and keyring.get_password("atomict", "token").

2. **Token Encryption**: If keyring is unavailable, encrypt the token using a user-derived key (e.g., via cryptography.fernet) before storing in JSON. Derive the key from a master password or OS secure prompt.

3. **Short-Lived Tokens**: Implement token refresh mechanisms. Store refresh tokens securely and automatically rotate access tokens on expiry. Client should check token validity before use and re-authenticate if invalid.

4. **Environment Variable Preference**: Enforce AT_TOKEN via env vars for non-persistent sessions, with warnings for file storage.

5. **File Permissions**: Set strict permissions on config.json (e.g., 600) post-creation.

6. **Audit and Logging**: Add logging for token access attempts and validate server responses for token metadata (e.g., expiry).

Implement and test fixes to ensure compatibility across OSes. Re-scan after patching.
