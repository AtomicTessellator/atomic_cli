# Insecure Authentication Token Storage

**ID:** vuln-0002
**Severity:** HIGH
**Found:** 2025-10-16 16:15:46 UTC

## Description

Vulnerability Description:
The Atomic Tessellator CLI application stores authentication tokens in plaintext within a user-specific configuration file. After successful authentication via username/password, the received token is persisted using the store() function in env.py, which writes it unencrypted to ~/.config/atomict/config.json (or equivalent OS-specific path). This file is readable by any process or user with access to the user's home directory, exposing the token to theft. The token is a simple bearer token (not JWT) used for all subsequent API requests to https://api.atomictessellator.com.

Affected Components:
- auth.py: Handles authentication and calls store("token", response["token"]) to persist the token.
- env.py: Implements store(), get(), and get_config_path() functions, which manage the JSON config file without encryption.
- cli/core/client.py: APIClient class loads the token from config via Config (implied integration) and sets it in HTTP headers as "Authorization: Token {token}". No validation or expiration checks on the client side.

Proof of Concept:
1. Simulate authentication: Run Python code to mimic the auth flow:
   from atomict.env import store
   mock_token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
   store("token", mock_token)
2. Verify storage: The file ~/.config/atomict/config.json contains: {"token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"}
3. Demonstrate exploitation: Any attacker with read access to the file can extract the token and use it in API requests (e.g., via curl: curl -H "Authorization: Token {stolen_token}" https://api.atomictessellator.com/api/user/ to access user data).

Impact:
High: Token theft enables full account takeover, allowing unauthorized access to user projects, simulations, tasks, and sensitive computational data. No client-side mitigations (e.g., token binding, expiration enforcement) exacerbate the risk. In multi-user environments or compromised machines, this could lead to data exfiltration or manipulation of scientific computations.

CVSS v3.1 Score: 7.5 (High)
- Attack Vector: Local (AV:L)
- Attack Complexity: Low (AC:L)
- Privileges Required: Low (PR:L)
- User Interaction: None (UI:N)
- Scope: Unchanged (S:U)
- Confidentiality: High (C:H)
- Integrity: None (I:N)
- Availability: None (A:N)
Base Score Calculation: 0.97 * (High Confidentiality) adjusted for local vector.

Remediation Steps:
1. Integrate secure credential storage: Use Python's keyring library (keyring.set_password("atomict", "token", token_value)) to store tokens in the OS credential manager (e.g., macOS Keychain, Windows Credential Manager, Linux Secret Service).
2. Update env.py: Replace store()/get() for sensitive keys with keyring calls. Fallback to encrypted files if keyring unavailable.
3. Add token validation: Implement client-side checks for token expiration (if server provides exp claim) and refresh mechanisms.
4. Environment variable handling: Warn or deprecate plaintext AT_TOKEN env var; encourage secure alternatives.
5. File permissions: Ensure config directory/files have strict permissions (e.g., 0600) via os.chmod after writing.
6. Testing: Add unit tests for secure storage and validate no plaintext persistence.

References:
- OWASP API Security Top 10: A05:2023 Broken Authentication
- CWE-798: Use of Hard-coded Credentials (adapted for storage)
- Similar issues in CLI tools: GitHub token storage vulns (GHSA-...)
